-- @todo: runloop should track all cords, and if all corded functions have exited, then runloop
--   should exit.

'bangnylon' crequire! as nsys

nsys.asthread as asthread


def :cord cordfun = {

    def :the-startup-coroutine-wrapper xcord = {
      xcord.coro nsys.register-thread!
      xcord.coro nsys.schedule!
      save-stack! as ss
      yield-nil!
      ss! xcord cordfun!
      xcord.coro nsys.unregister-thread!
    }
    
    the-startup-coroutine-wrapper coroutine! as coro
--    cordfun coroutine! as coro

    def :schedule = coro nsys.schedule!;

    def :sleep seconds = {
--        seconds 'starting timer callback after %s seconds\n' print!
        fun = {
--            seconds 'got timer callback after %s seconds\n' print!
            coro nsys.schedule!
        } seconds nsys.addOneShot!

        yield!
--        seconds 'coroutine woke up after %s seconds\n' print!
    }

    def :asthread torun = {
        torun coro nsys.asthread! yield-nil!
    }

    fun = lookup; as f-lookup

--    'calling coroutine\n' print!
    
    f-lookup coro!

    f-lookup
}

nsys.waitforthread as waitforthread
nsys.have-threads as have-threads

def :runloop = {
    have-threads! as have-any
--    have-any # 'any=%@ stk=%s nylon mainloop wait for thread\n' print!
    have-any ? 
      waitforthread! as thread
--      # thread 'stk=%s nylon mainloop got thread=%s\n' print!
      thread!
      runloop!
}


fun = lookup
